// Code generated by generator/generate.go DO NOT EDIT.

package pkg1_test

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"mime"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"net/textproto"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/deepmap/oapi-codegen/v2/internal/test/strict-server-matrix/pkg1"
	"github.com/deepmap/oapi-codegen/v2/internal/test/strict-server-matrix/pkg2"
)

type strictServerInterface struct{}

func (s strictServerInterface) TestWildcardMultipart(ctx context.Context, request pkg1.TestWildcardMultipartRequestObject) (pkg1.TestWildcardMultipartResponseObject, error) {
	return pkg1.TestWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestFixedWildcardMultipart(ctx context.Context, request pkg1.TestFixedWildcardMultipartRequestObject) (pkg1.TestFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestFixedWildcardMultipart200MultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	}), nil
}

func TestFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderWildcardMultipart(ctx context.Context, request pkg1.TestHeaderWildcardMultipartRequestObject) (pkg1.TestHeaderWildcardMultipartResponseObject, error) {
	return pkg1.TestHeaderWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderWildcardMultipartdefaultResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestHeaderWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderFixedWildcardMultipart(ctx context.Context, request pkg1.TestHeaderFixedWildcardMultipartRequestObject) (pkg1.TestHeaderFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestHeaderFixedWildcardMultipart200MultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderFixedWildcardMultipart200ResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		ContentType: "multipart/baz",
	}, nil
}

func TestHeaderFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefWildcardMultipart(ctx context.Context, request pkg1.TestRefWildcardMultipartRequestObject) (pkg1.TestRefWildcardMultipartResponseObject, error) {
	return pkg1.TestRefWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestRefWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefFixedWildcardMultipart(ctx context.Context, request pkg1.TestRefFixedWildcardMultipartRequestObject) (pkg1.TestRefFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestRefFixedWildcardMultipart200MultipartResponse(pkg1.TestRespRefFixedWildcardMultipartMultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	})), nil
}

func TestRefFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderWildcardMultipart(ctx context.Context, request pkg1.TestRefHeaderWildcardMultipartRequestObject) (pkg1.TestRefHeaderWildcardMultipartResponseObject, error) {
	return pkg1.TestRefHeaderWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderWildcardMultipartResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestRefHeaderWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderFixedWildcardMultipart(ctx context.Context, request pkg1.TestRefHeaderFixedWildcardMultipartRequestObject) (pkg1.TestRefHeaderFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestRefHeaderFixedWildcardMultipart200MultipartResponse{pkg1.TestRespRefHeaderFixedWildcardMultipartMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderFixedWildcardMultipartResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		ContentType: "multipart/baz",
	}}, nil
}

func TestRefHeaderFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestExtWildcardMultipart(ctx context.Context, request pkg1.TestExtWildcardMultipartRequestObject) (pkg1.TestExtWildcardMultipartResponseObject, error) {
	return pkg1.TestExtWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg2.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestExtWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ext-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestExtWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg2.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg2.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestExtFixedWildcardMultipart(ctx context.Context, request pkg1.TestExtFixedWildcardMultipartRequestObject) (pkg1.TestExtFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestExtFixedWildcardMultipart200MultipartResponse(pkg2.TestRespExtFixedWildcardMultipartMultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg2.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	})), nil
}

func TestExtFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ext-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestExtFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg2.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg2.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestExtHeaderWildcardMultipart(ctx context.Context, request pkg1.TestExtHeaderWildcardMultipartRequestObject) (pkg1.TestExtHeaderWildcardMultipartResponseObject, error) {
	return pkg1.TestExtHeaderWildcardMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg2.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg2.TestRespExtHeaderWildcardMultipartResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		StatusCode:  200,
		ContentType: "multipart/baz",
	}, nil
}

func TestExtHeaderWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ext-header-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestExtHeaderWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg2.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg2.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestExtHeaderFixedWildcardMultipart(ctx context.Context, request pkg1.TestExtHeaderFixedWildcardMultipartRequestObject) (pkg1.TestExtHeaderFixedWildcardMultipartResponseObject, error) {
	return pkg1.TestExtHeaderFixedWildcardMultipart200MultipartResponse{pkg2.TestRespExtHeaderFixedWildcardMultipartMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg2.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg2.TestRespExtHeaderFixedWildcardMultipartResponseHeaders{
			Header1: "foo",
			Header2: 123,
		},
		ContentType: "multipart/baz",
	}}, nil
}

func TestExtHeaderFixedWildcardMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ext-header-fixed-wildcard-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestExtHeaderFixedWildcardMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "foo", res.HTTPResponse.Header.Get("header1"))
	assert.Equal(t, "123", res.HTTPResponse.Header.Get("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/baz", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg2.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg2.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}
